<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <title>Peersim-Pht by nongbottom</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">

    <link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow' rel='stylesheet' type='text/css'>
</head>
<body>
<section class="page-header">
    <h1 class="project-name">
        Peersim-Pht
        <a href="https://github.com/nongbottom/Peersim-pht">
            <img src="../GitHub-Logo2.png"
                 alt="Github logo"
                 style="height:42px;width:42px">
        </a>
    </h1>
    <a href="../../index.html" class="btn">Home</a>
    <a href="../fr/rapport.html" class="btn">Report</a>
    <a href="pht_doc.html" class="btn">Documentation</a>

    <br />
    <a href="pht_doc.html" class="rapport">Pht</a>
    <a href="how_works.html" class="rapport rapport-current">How it works</a>
</section>

<section class="main-content">

    <p class="resume">
        We will discuss in this section about how every operation works. We will start with how message are structured,
        , discuss in more detail the client operations (insert, delete, lookup, range query) and the more internal
        ones: split, merge, number of keys update...and finally look at the Dht interface.
    </p>

    <h2 id="async-comm-messages">Messages</h2>
    <p>
        Every communication is asynchronous and every message between two (possible) remote machine has an acquittal.
        A message from a Pht node to another is a PhtMessage: this message contains the minimum information such as
        the initiator of the operation. If more information is needed, a PhtMessage can be extended with a PMLookup,
        which can also be extended with a PMRangeQuery. This works like a russian doll: PhtMessage is the biggest one,
        PMLookup is the one a little bit smaller and PMRangeQuery again a little bit smaller. This system avoids having
        one big type of message with unused fields for the majority of operations.
    </p>

    <p><b>PhtMessage</b> has the following fields:</p>
    <ol>
        <li>type</li>
        <li>initiator node (physical machine, not Pht node)</li>
        <li>initiator label (Pht node - null for operations not triggered by a Pht node)</li>
        <li>more (Integer, Boolean or PMLookup)</li>
        <li>id</li>
    </ol>

    <p><b>PMLookup</b> is used for lookups. The <em>dest</em> and <em>destlabel</em> fiels are used for dierct
    communications: the sender puts its information in the PhtMessage and the recipient his own in the PMLookup.</p>
    <ol>
        <li>key</li>
        <li>operation (second operation if the lookup is only the first step - like insertion or delete)</li>
        <li>dest (destination node (physical machine, not Pht node))</li>
        <li>label of the destination Pht node</li>
        <li>less (add extra information like a PMRangeQuery, when needed)</li>
    </ol>

    <p><b>PMRangeQuery</b> is used for range query messages.</p>
    <ol>
        <li>keyMin (minimal key of the searched range)</li>
        <li>keyMax (maximal key of the searched range)</li>
        <li>kdata (list of (key, data) values send to the initiator of the range query)</li>
        <li>count (count the number of leaves - only for sequential queries)</li>
        <li>end (is this messages a message from the last leaf of the query ?)</li>
    </ol>

    <p>Note that since this is used for simulations, we can use the same PhtMessage during the whole operation (every
    step and every acquittal), it can be helpful for debug. This means that the <span class="code">more</span> field of
        a PhtMessage can change from a PMLookup to a Boolean for example.</p>

    <h3 id="ascyn-comm-routing">Routing and direct communications</h3>
    <p>
        Pht relies on a Dht for routing operation, when a node does not know on which machine is another node. Almost
        all dht provide a O(log N) complexity for a lookup which is good. But, route every message between two Pht
        nodes using the Dht can be way too expensive. So, to avoid as much as possible these routing, direct
        communications are used between Pht nodes. This means:
    </p>
    <ol>
        <li>A message must contain information to enable direct communication (as soon as possible).</li>
        <li>A Pht node maintains information about its sons and father (if any) physical machine it keep them up to
        date.</li>
    </ol>

    <p>
        The second point is not yet updated since we suppose, for now, that the network is static (partly due to the
        absence of Dht implementation with data replication on PeerSim's website).
    </p>

    <!-- Client -->

    <h2 id="ext-op">Client</h2>
    <p>
        The overall conduct of an operation goes like this (we do not treat the case of a client outside of the peer to
        peer network network):
    </p>
        <ol>
            <li>The client asks the Pht layer for an operation.</li>
            <li>The Pht layer sends a first response with an operation id if the operation can start or an error
            code (negative value) if the layer cannot start a new operation.</li>
            <li>The Pht layer starts the operation with asynchronous communications.</li>
            <li>When it receives the final answer (data searched, final acquittal), it informs the client.</li>
        </ol>
    <p>
        Since the communications with the client are trivial, we will focus only on the Pht part.
    </p>

    <h3 id="ext-op-insertion">Insertion</h3>
    <p>
        An insertion is a two steps operation:
    </p>
        <ol>
            <li>Lookup to seek for the Pht node responsible for the given key.</li>
            <li>The key and the data is send to this node directly (without Dht routing).</li>
        </ol>
    <p>
        Note as for every operation, each step has an acquittal: the first is used to inform the initiator (hence the
        direct connection is possible), and the last to provide information about the insertion (everything went ok or
        not, a split has started or not).
    </p>

    <h3 id="ext-op-delete">Delete</h3>
    <p>
        A delete operation is even simpler: a lookup is send with a key. The Pht node responsible for this key will
        remove the data with the given key if it exists.
    </p>

    <h3 id="ext-op-lookup">Lookup</h3>
    <p>
        There are two sorts of lookup: binary and linear. The first one always starts with a Dht routing to get to the
        root node. After that, it runs through the tree until a leaf is found: the lookup is forwarded using the direct
        links nodes maintain between them. The second one tries prefix of different lengths until a node is found.
        After that, the binary lookup behaves like the linear. The first method has some advantages over the second one:
    </p>
    <dl>
        <dt>It is resistant to a node failure</dt>
        <dd>When using different prefixes, it is not possible to know at each step if the node does not exist or if
        it is down.</dd>
        <dt>It can avoid many expansive Dht routing</dt>
        <dd>if only a few nodes are down, almost every message from the root
        node to the leaf will be passed using direct connections.</dd>
    </dl>
    <p>
        On the other hand, the second one has one significant advantage: it does not necessarily pass through the root.
        This is important since linear lookup can create a bottleneck.
    </p>
    <p>
        In this first version, the network is supposed to be static, there is no node failure. So, a linear lookup
        is always at least as fast as the binary way (it is as fast at the beginning when there is only one leaf: the
        root node). Still, the advantages of one over another does not change.
    </p>
    <p>
        We have to mention here that our binary lookup has a little difference with the one described in the original
        paper: it does not continue Dht routing with longer prefixes when an internal node is found. This is a way to
        avoid Dht routing which can be expansive.
    </p>

    <h3 id="ext-op-rangeq">Range Queries</h3>
    <p>
        This kind of operation is the Pht's main reason to exist. Like lookups, there are two sorts of range queries:
        the sequential one and the parallel. The first starts a lookup for the leaf responsible for the minimum key of
        the range. Once the message arrives to this leaf, the range query is forwarded using the links between the
        leaves. The second approch does not use those links. The parallel query starts a lookup with the smallest
        common prefix between the minimum and maximum keys of the range. Once this node is found, his sub-tree is
        flooded with the range query. When a leaf receives a message, if it responsible for keys inside the range, it
        sends the appropriate keys to the query initiator.
    </p>

    <div style="text-align: center;">
        <img src="img/pht-seq.png" alt="Pht sequential query" style="width: 250px; margin: 0 35px;
    display: inline-block;">
        <img src="img/pht-par.png" alt="Pht parallel query" style="width: 250px; margin: 0 35px;
    display: inline-block;">
    </div>

    <p>
        Examples of a query over the range ['0000', '0110'], the first is the sequential and the other one is the
        parallel range query. The purple represents the leaves and the bidirectional links between them.
    </p>

    <h4>Termination detection</h4>
    <p>
        The initiator of the range query must know how many messages it must receives, in other words: how many leaves
        must sent him a message with keys and data.
    </p>
    <p>
        <b>Sequential</b>: the range query message contains a counter that is incremented at each leaf, and a flag set
        to true by the last leaf of the query. When the initiator receives the message from the last leaf (which does
        not have to be the last one received), he knows how many more message must be sent to him.
    </p>
    <p>
        <b>Parallel</b>: to inform the initiator about the number of message he must receive, every node on the flooded
        sub-tree must sens and acquittal with a counter (similar to the one of sequential query) to its father. The
        node from where the flood began will be able to send a message to the initiator with the number of messages he
        must reveive.
    </p>

    <p>
        In the worst case (the range covers all the leaves and the Pht is complete), the parallel is (much) faster than
        the sequential query.
        Let D be the length of a key, thus the height of a Pht is O(D). Since a parallel query starts with a lookup and
        then floods the entire sub-tree, every leaf receives the range query message within O(D) steps. A sequential
        query with the same range will take more steps (except if the height(Pht) &leq; 1): since the tree is complete,
        there are O(2<sup>height(Pht)</sup>) leaves to travel.
    </p>
    <p>
        The worst case complexity of the parallel search is better, however, one must not forget that this has a cost:
        more messages inside the Pht. In the sequential query the only internal nodes who will be used are those on the
        path between the root and the first leaf of the range. In the parallel query, every internal in the sub-tree of
        the smallest common prefix node will forward the range query and send an acquittal to their father.
    </p>

    <!-- Internal operations -->

    <h2 id="internal-op">Internal operations</h2>

    <h3 id="internal-op-split">Split</h3>
    <p>
        A split operation can be triggered after an insertion under two conditions:
    </p>
    <ol>
        <li>A leaf has more than <em>B</em> keys.</li>
        <li>There cannot be two consecutive splits.</li>
    </ol>

    <p>
        The first condition is <a href="pht_doc.html">a property of the Pht</a>. The second on the other hand may
        violate the same property. A split is a three step operation:
    </p>
    <dl>
        <dt>Dht routing</dt>
        <dd>For each son, a split message is send using the Dht layer.
            When a machine receives a message of this type with a label, it create a Pht node of the
        same label.</dd>

        <dt>Send leaves</dt>
        <dd>
            Once the father has received an acquittal of its two sons, he can send back their leaves (next and previous
            leaves links).
            <ul>
                <li><b>Left son</b>: the previous leaf is the father's previous leaf and the next one the right son.
                </li>
                <li><b>Right son</b>: the previous leaf is the left son and the next leaf is the father's next leaf.
                </li>
            </ul>
        </dd>

        <dt>Send keys</dt>
        <dd>
            When a son sends an acquittal for the leaves, the father sends him back keys that starts with <em>l0</em>
            if the son is the left one and <em>l1</em> otherwise (<em>l</em> is the father's label).
        </dd>
    </dl>

    <h3 id="internal-op-merge">Merge</h3>
    <p>
        A merge operation can be triggered after a delete under two conditions:
    </p>
    <ol>
        <li>An ancestor has less than <em>B + 1</em> nodes in its sub-tree.</li>
        <li>This delete has not triggered a merge already.</li>
    </ol>

    <p>
        Those conditions are similar to those for a split. A merge is a three step operation:
    </p>
    <dl>
        <dt>Ask for merge</dt>
        <dd>
            It is necessary to ask to a merge before really starting one. The merge will really be made if the two sons
            are leaves, otherwise this could lead to a series of merge which we do not want.
        </dd>

        <dt>Send leaves</dt>
        <dd>
            The sons send their previous and next leaves to their father who will update its previous and next leaves
            accordingly.
        </dd>

        <dt>Send keys</dt>
        <dd>
            The sons send their keys back to their father. When the father has received the leaves and the keys from
            its two sons, the merge is done.
        </dd>
    </dl>

    <h3 id="internal-op-update">Update number of keys</h3>
    <p>
        A leaf knows how many keys it has and an internal knows how many keys are in its sub-tree (otherwise there
        could be no merge). So, every time a key is inserted or removed an update message is sent from the leaf to all
        its ancestors (from his father to the root node).
    </p>

    <h3 id="internal-op-problem">Asynchrony and threaded leaves</h3>
    <p>
        A split and a merge implies to send update messages for the threaded leaves. Imagine that a node has to split.
        His left son will send an update message to the previous leaf (and the right son another to the next leaf).
        Imagine now, that the previous leaf splits between the first split and the receipt of the update message: it
        will have to forward the message to its right son. The same kind of problem happens with a merge or a merge and
        a split, or multiple splits and/or merges...
    </p>
    <p>
        If an internal receives an update message regarding threaded leaves it will be able to forward it to one if its
        son, using direct communication. With a merge a message can arrive on a leaf that has just merged. With the
        label of the leaf, it is possible to find its father's label easily, but direct communication is not possible.
        Therefore, if the dht has some routing problem, the message might be forwarded to the wrong machine (PeerSim
        Node) and lead to an error.
    </p>

    <!-- Dht interface -->

    <h2 id="dht-interface">Dht interface</h2>

    <p>
        To use a Dht, it is necessary to implement the <span class="code">DhtInterface</span> interface. Depending on
        the implementation, it might be necessary to provide more stuff. This is true for the mspastry protocol from
        PeerSim.
    </p>
    <ul>
        <li><span class="code">public void send(PhtMessage message, String dest)</span></li>
    </ul>

    <h3 id="dht-interface-pastry">Pastry</h3>
    <p>
        The <a href="http://peersim.sourceforge.net/#code">pastry package for PeerSim</a> has been chosen as a first
        Dht for Pht. The integration with Pht is composed of three classes:
    </p>
    <dl>
        <dt>MSPastry</dt>
        <dd>
            Small class implementing the <span class="code">DhtInterface</span> interface, with the main method
            <span class="code">send</span>.
        </dd>

        <dt>MSPInit</dt>
        <dd>
            MSPInit is in charge of initiate everything: give every layer on the physical machine the information it
            needs like a reference to a <span class="code">MSPastryProtocol</span>, a
            <span class="code">DhtInterface</span>, etc.
        </dd>

        <dt>MSPastryListener</dt>
        <dd>
            The <span class="code">MSPastryProtocol</span> class has a <span class="code">Listener</span> type field
            (named listener). This interface has one method: <span class="code">public void receive(Message m)</span>
            that can be used to define more action to do when a message has reached its destination. In this cas, the
            <span class="code">MSPastryListener</span> class extracts the <span class="code">PhtMessage</span> from the
            <span class="code">Message</span> (Dht message) and passes it to a <span class="code">PhtProtocol</span>.
        </dd>
    </dl>

    <!-- Retry -->

    <h2 id="retry">Retry</h2>

    <p>
        A Pht node is an unstable state when a split or a merge operation is ongoing. It is in a stable state the rest
        of the time.
    </p>

    <p>
        In an unstable state, a node will refuse any operation. The initiator node of the operation will receive a
        message informing him that the operation has been stopped and that he should try it again later. The node will
        try again in maximum_delay * retry_factor time units.
    </p>

    <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/nongbottom/Peersim-pht">Peersim-pht</a> is maintained by <a href="https://github.com/nongbottom">nongbottom</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
    </footer>

</section>
</body>
</html>
