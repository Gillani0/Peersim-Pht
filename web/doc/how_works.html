<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <title>Peersim-Pht by nongbottom</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">

    <link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow' rel='stylesheet' type='text/css'>
</head>
<body>
<section class="page-header">
    <h1 class="project-name">
        Peersim-Pht
        <a href="https://github.com/nongbottom/Peersim-pht">
            <img src="../GitHub-Logo2.png"
                 alt="Github logo"
                 style="height:42px;width:42px">
        </a>
    </h1>
    <a href="../../index.html" class="btn">Home</a>
    <a href="../fr/rapport.html" class="btn">Rapport</a>
    <a href="documentation.html" class="btn">Documentation</a>

    <br />
    <a href="pht_doc.html" class="rapport">Pht</a>
    <a href="quick_overview.html" class="rapport">Quick overview</a>
    <a href="how_works.html" class="rapport rapport-current">How it works</a>
    <a href="choices.html" class="rapport">Choices</a>
</section>

<div id="menu">
    <ul>
        <li><a href="#asyn-comm">Asynchronous communications</a>
            <ol>
                <li><a href="#asyn-comm-messages">Messages</a></li>
            </ol>
        </li>
        <li><a href="#ext-op">External operations</a>
            <ol>
                <li><a href="#ext-op-insertion">Insertion</a></li>
                <li><a href="#ext-op-delete">Delete</a></li>
                <li><a href="#ext-op-lookup">Lookup</a></li>
                <li><a href="#ext-op-rangeq">Range queries</a></li>
            </ol>
        </li>
        <li><a href="#internal-op">Internal operations</a>
            <ol>
                <li><a href="#internal-op-split">Split</a></li>
                <li><a href="#internal-op-merge">Merge</a></li>
                <li><a href="#internal-op-update">Update</a></li>
            </ol>

        </li>
    </ul>
</div>

<section class="main-content" id="content">

    <p class="resume">
        We will discuss in this section about how every operation works. We will start with the external operations,
        the one which a client uses (insert, delete, lookup, range query) with its variants (binary and linear lookups,
        sequential and parallel range queries). And maintenance operations in the second part, indirectly
        triggered by a client (split, merge, update number of keys).
    </p>

    <h2 id="asyn-comm">Asynchronous communications</h2>
    <p>
        Every communication is asynchronous and every message between two (possible) remote machine has an acquittal.
        A message from a Pht node to another is a PhtMessage: this message contains the minimum information such as
        the initiator of the operation. If more information is needed, a PhtMessage can be extended with a PMLookup,
        which can also be extended with a PMRangeQuery. This works like a russian doll: PhtMessage is the biggest one,
        PMLookup is the one a little bit smaller and PMRangeQuery again a little bit smaller. This system avoids having
        one big type of message with unused fields for the majority of operations.
    </p>

    <h3 id="async-comm-messages">Messages</h3>

    <p><b>PhtMessage</b> has the following fields:</p>
    <ol>
        <li>type</li>
        <li>initiator node (physical machine, not Pht node)</li>
        <li>initiator label (Pht node - null for operations not triggered by a Pht node)</li>
        <li>more (Integer, Boolean or PMLookup)</li>
        <li>id</li>
    </ol>

    <p><b>PMLookup</b> is used for lookups. The <em>dest</em> and <em>destlabel</em> fiels are used for dierct
    communications: the sender puts its information in the PhtMessage and the recipient his own in the PMLookup.</p>
    <ol>
        <li>key</li>
        <li>operation (second operation if the lookup is only the first step - like insertion or delete)</li>
        <li>dest (destination node (physical machine, not Pht node))</li>
        <li>label of the destination Pht node</li>
        <li>less (add extra information like a PMRangeQuery, when needed)</li>
    </ol>

    <p><b>PMRangeQuery</b> is used for range query messages.</p>
    <ol>
        <li>keyMin (minimal key of the searched range)</li>
        <li>keyMax (maximal key of the searched range)</li>
        <li>kdata (list of (key, data) values send to the initiator of the range query)</li>
        <li>count (count the number of leaves - only for sequential queries)</li>
        <li>end (is this messages a message from the last leaf of the query ?)</li>
    </ol>

    <p>Note that since this is used for simulations, we can use the same PhtMessage during the whole operation (every
    step and every acquittal), it can be helpful for debug. This means that the <span class="code">more</span> field of
        a PhtMessage can change from a PMLookup to a Boolean for example.</p>

    <h3 id="ascyn-comm-routing">Routing and direct communications</h3>
    <p>
        Pht relies on a Dht for routing operation, when a node does not know on which machine is another node. Almost
        all dht provide a O(log N) complexity for a lookup which is good. But, route every message between two Pht
        nodes using the Dht can be way too expensive. So, to avoid as much as possible these routing, direct
        communications are used between Pht nodes. This means:
    </p>
    <ol>
        <li>A message must contain information to enable direct communication (as soon as possible).</li>
        <li>A Pht node maintains information about its sons and father (if any) physical machine it keep them up to
        date.</li>
    </ol>

    <p>
        The second point is not yet updated since we suppose, for now, that the network is static (partly due to the
        absence of Dht implementation with data replication on PeerSim's website).
    </p>

    <!-- External operations -->

    <h2 id="ext-op">External operations</h2>
    <p>
        The overall conduct of an operation goes like this (we do not treat the case of a client outside of the peer to
        peer network network):
    </p>
        <ol>
            <li>The client asks the Pht layer for an operation.</li>
            <li>The Pht layer sends a first response with an operation id if the operation can start or an error
            code (negative value) if the layer cannot start a new operation.</li>
            <li>The Pht layer starts the operation with asynchronous communications.</li>
            <li>When it receives the final answer (data searched, final acquittal), it informs the client.</li>
        </ol>
    <p>
        Since the communications with the client are trivial, we will focus only on the Pht part.
    </p>

    <h3 id="ext-op-insertion">Insertion</h3>
    <p>
        An insertion is a two steps operation:
    </p>
        <ol>
            <li>Lookup to seek for the Pht node responsible for the given key.</li>
            <li>The key and the data is send to this node directly (without Dht routing).</li>
        </ol>
    <p>
        Note as for every operation, each step has an acquittal: the first is used to inform the initiator (hence the
        direct connection is possible), and the last to provide information about the insertion (everything went ok or
        not, a split has started or not).
    </p>

    <h3 id="ext-op-delete">Delete</h3>
    <p>
        A delete operation is even simpler: a lookup is send with a key. The Pht node responsible for this key will
        remove the data with the given key if it exists.
    </p>

    <h3 id="ext-op-lookup">Lookup</h3>
    <p>
        There are two sorts of lookup: binary and linear. The first one always starts with a Dht routing to get to the
        root node. After that, it runs through the tree until a leaf is found: the lookup is forwarded using the direct
        links nodes maintain between them. The second one tries prefix of different lengths until a node is found.
        After that, the binary lookup behaves like the linear. The first method has some advantages over the second one:
    </p>
    <dl>
        <dt>It is resistant to a node failure</dt>
        <dd>When using different prefixes, it is not possible to know at each step if the node does not exist or if
        it is down.</dd>
        <dt>It can avoid many expansive Dht routing</dt>
        <dd>if only a few nodes are down, almost every message from the root
        node to the leaf will be passed using direct connections.</dd>
    </dl>
    <p>
        On the other hand, the second one has one significant advantage: it does not necessarily pass through the root.
        This is important since linear lookup can create a bottleneck.
    </p>
    <p>
        In this first version, the network is supposed to be static, there is no node failure. So, a linear lookup
        is always at least as fast as the binary way (it is as fast at the beginning when there is only one leaf: the
        root node). Still, the advantages of one over another does not change.
    </p>
    <p>
        We have to mention here that our binary lookup has a little difference with the one described in the original
        paper: it does not continue Dht routing with longer prefixes when an internal node is found. This is a way to
        avoid Dht routing which can be expansive.
    </p>

    <h3 id="ext-op-rangeq">Range Queries</h3>
    <p>
        This kind of operation is the Pht's main reason to exist. Like lookups, there are two sorts of range queries:
        the sequential one and the parallel. The first starts a lookup for the leaf responsible for the minimum key of
        the range. Once the message arrives to this leaf, the range query is forwarded using the links between the
        leaves. The second approch does not use those links. The parallel query starts a lookup with the smallest
        common prefix between the minimum and maximum keys of the range. Once this node is found, his sub-tree is
        flooded with the range query. When a leaf receives a message, if it responsible for keys inside the range, it
        sends the appropriate keys to the query initiator.
    </p>

    <div style="text-align: center;">
        <img src="img/pht-seq.png" alt="Pht sequential query" style="width: 250px; margin: 0px 35px;
    display: inline-block;">
        <img src="img/pht-par.png" alt="Pht parallel query" style="width: 250px; margin: 0px 35px;
    display: inline-block;">
    </div>

    <p>
        Examples of a query over the range ['0000', '0110'], the first is the sequential and the other one is the
        parallel range query. The purple represents the leaves and the bidirectional links between them.
    </p>

    <h4>Termination detection</h4>
    <p>
        The initiator of the range query must know how many messages it must receives, in other words: how many leaves
        must sent him a message with keys and data.
    </p>
    <p>
        <b>Sequential</b>: the range query message contains a counter that is incremented at each leaf, and a flag set
        to true by the last leaf of the query. When the initiator receives the message from the last leaf (which does
        not have to be the last one received), he knows how many more message must be sent to him.
    </p>
    <p>
        <b>Parallel</b>: to inform the initiator about the number of message he must receive, every node on the flooded
        sub-tree must sens and acquittal with a counter (similar to the one of sequential query) to its father. The
        node from where the flood began will be able to send a message to the initiator with the number of messages he
        must reveive.
    </p>

    <p>
        In the worst case (the range covers all the leaves and the Pht is complete), the parallel is (much) faster than
        the sequential query.
        Let D be the length of a key, thus the height of a Pht is O(D). Since a parallel query starts with a lookup and
        then floods the entire sub-tree, every leaf receives the range query message within O(D) steps. A sequential
        query with the same range will take more steps (except if the height(Pht) &leq; 1): since the tree is complete,
        there are O(2<sup>height(Pht)</sup>) leaves to travel.
    </p>
    <p>
        The worst case complexity of the parallel search is better, however, one must not forget that this has a cost:
        more messages inside the Pht. In the sequential query the only internal nodes who will be used are those on the
        path between the root and the first leaf of the range. In the parallel query, every internal in the sub-tree of
        the smallest common prefix node will forward the range query and send an acquittal to their father.
    </p>

    <!-- Internal operations -->

    <h2 id="internal-op">Internal operations</h2>

    <h3 id="internal-op-split">Split</h3>
    <p>
        A split operation can be triggered after an insertion under two conditions:
    </p>
    <ol>
        <li>A leaf has more than <em>B</em> keys.</li>
        <li>There cannot be two consecutive splits.</li>
    </ol>

    <p>
        The first condition is <a href="pht_doc.html">a property of the Pht</a>. The second on the other hand may
        violate the same property. This possibility is discussed in the <a href="choices.html#insert">choices
        section</a>. A split is a three step operation:
    </p>
    <dl>
        <dt>Dht routing</dt>
        <dd>For each son, a split message is send using the Dht layer.
            When a machine receives a message of this type with a label, it create a Pht node of the
        same label.</dd>

        <dt>Send leaves</dt>
        <dd>
            Once the father has received an acquittal of its two sons, he can send back their leaves (next and previous
            leaves links).
            <ul>
                <li><b>Left son</b>: the previous leaf is the father's previous leaf and the next one the right son.
                </li>
                <li><b>Right son</b>: the previous leaf is the left son and the next leaf is the father's next leaf.
                </li>
            </ul>
        </dd>

        <dt>Send keys</dt>
        <dd>
            When a son sends an acquittal for the leaves, the father sends him back keys that starts with <em>l0</em>
            if the son is the left one and <em>l1</em> otherwise (<em>l</em> is the father's label).
        </dd>
    </dl>

    <h3 id="internal-op-merge">Merge</h3>
    <p>
        A merge operation can be triggered after a delete under two conditions:
    </p>
    <ol>
        <li>An ancestor has less than <em>B + 1</em> nodes in its sub-tree.</li>
        <li>This delete has not triggered a merge already.</li>
    </ol>

    <p>
        Those conditions are similar to those for a split. Please read the <a href="choices.html#delete">choices
        section</a> for more details. A merge is a three step operation:
    </p>
    <dl>
        <dt>Ask for merge</dt>
        <dd>
            It is necessary to ask to a merge before really starting one. The merge will really be made if the two sons
            are leaves, otherwise this could lead to a series of merge which we do not want.
        </dd>

        <dt>Send leaves</dt>
        <dd>
            The sons send their previous and next leaves to their father who will update its previous and next leaves
            accordingly.
        </dd>

        <dt>Send keys</dt>
        <dd>
            The sons send their keys back to their father. When the father has received the leaves and the keys from
            its two sons, the merge is done.
        </dd>
    </dl>

    <h3 id="internal-op-update">Update number of keys</h3>
    <p>
        A leaf knows how many keys it has and an internal knows how many keys are in its sub-tree (otherwise there
        could be no merge). So, every time a key is inserted or removed an update message is sent from the leaf to all
        its ancestors (from his father to the root node).
    </p>

    <!-- Dht interface -->

    <h2 id="dht-interface">Dht interface</h2>

    <p>
        To use a Dht, it is necessary to implement the <span class="code">DhtInterface</span> interface. Depending on
        the implementation, it might be necessary to provide more stuff. This is true for the mspastry protocol from
        PeerSim.
    </p>
    <ol>
        <li><span class="code">public void send(PhtMessage message, String dest)</span></li>
        <li><span class="code">public Object getNodeId()</span></li>
    </ol>
    <p>
        To make a quick comparison with the TCP/IP model, one could say that the Dht is the Link/Internet layers and
        Pht is the Transport/Application layers.
    </p>

    <h3 id="dht-interface-pastry">Pastry</h3>
    <p>
        The <a href="http://peersim.sourceforge.net/#code">pastry package for PeerSim</a> has been chosen as a first
        Dht for Pht. The integration with Pht is composed of three classes:
    </p>
    <dl>
        <dt>MSPastry</dt>
        <dd>
            Small class implementing the <span class="code">DhtInterface</span> interface, with the main method
            <span class="code">send</span>.
        </dd>

        <dt>MSPInit</dt>
        <dd>
            MSPInit is in charge of initiate everything: give every layer on the physical machine the information it
            needs like a reference to a <span class="code">MSPastryProtocol</span>, a
            <span class="code">DhtInterface</span>, etc.
        </dd>

        <dt>MSPastryListener</dt>
        <dd>
            The <span class="code">MSPastryProtocol</span> class has a <span class="code">Listener</span> type field
            (named listener). This interface has one method: <span class="code">public void receive(Message m)</span>
            that can be used to define more action to do when a message has reached its destination. In this cas, the
            <span class="code">MSPastryListener</span> class extracts the <span class="code">PhtMessage</span> from the
            <span class="code">Message</span> (Dht message) and passes it to a <span class="code">PhtProtocol</span>.
        </dd>
    </dl>

    <p>
    </p>

    <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/nongbottom/Peersim-pht">Peersim-pht</a> is maintained by <a href="https://github.com/nongbottom">nongbottom</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
    </footer>

</section>
</body>
</html>
